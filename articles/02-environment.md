# Setup the environment

To setup the initial environment I'll use a very basic `Dockerfile` and `docker-compose.yml` (I love using docker-compose to run my commands).

You can find all files in the `chapter-01-src` folder. Note that I'm using the `node` user in the Dockerfile. This is beacuse it has the same uid of my user in my local computer. You may need to add a user with a specific uid if you want to be able to edit the files generated by your docker container. You can read more in the [Github documentation](https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md#non-root-user).

We init our project with yarn launching the command `docker-compose run --rm node yarn init -y`. This will create a basic `package.json` file. With this file we can start tracking the packes we'll need.

Let's add typescript as a dev dependency: `docker-compose run --rm node yarn add -D typescript`. Now that typescript is installed, we can use it to initialize our `tsconfig.json` file: `docker-compose run --rm node yarn tsc --init --rootDir src --outDir dist`. We're specifying that our code will be in the `src` folder while the compiled vanilla js version will be in the `dist` folder.

## A new app is born

We're now ready to create our initial application. We'll use [express](https://expressjs.com/) to handle the requests: let's install it: `docker-compose run --rm node yarn add express`. Since we're using typescript, we'll need to add node and express types: `docker-compose run --rm node yarn add -D @types/express @types/node`.

Now we can use express to serve our responses. We create an `src/index.ts` wich will handle the reqquest. Here's is the file (you can find it in almost all articles of this kind...):

```
import express from 'express';

const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(port, () => {
  console.log(`[server]: Server is running at https://localhost:${port}`);
});
```

We start an application listening on port 3000 which will handle request to GET / and returns a string. To do this, we'll need to build the js code and to start the node server.

To do this, we'll need two `scripts` in the `package.json` file. They are `build` and `start`.

The first step is then made with the command `docker-compose run --rm node yarn run build`. This, will build an `index.js` file in the `dist` folder.

The second step is to start the server: `docker-compose up`. This will launch the container and the command `yarn run start` (from docker-compose file), which is a shortcut for `node dist/index.js`.

```
Recreating fp-articles_node_1 ... done
Attaching to fp-articles_node_1
node_1  | yarn run v1.22.19
node_1  | $ node dist/index.js
node_1  | [server]: Server is running at https://localhost:3000
```

Now you can `GET /` with your browser heading to https://localhost:3000

## Some refinement

Every time we change our code, we should stop the container, run `docker-compose run --rm node yarn build` and restart the container. Let's fix this and have a better dev experience.

We'll need [concurrently](https://www.npmjs.com/package/concurrently) and [nodemon](https://github.com/remy/nodemon) to handle this situation. It will concurrently start two commands:

- `tsc` in watch mode to re-compile our typescript every time is changes
- `nodemon` to restart the node service everytime the vanilla js is changed

Let's install `concurrently` and `nodemon`: `docker-compose run --rm node yarn add -D concurrently nodemon`

We'll add a new script in `packacge.json`: `"dev": "concurrently -k \"tsc -p ./ -w\" \"nodemon ./dist\""`.

Now we can update the docker-compose file to launch this command. Let's start the container and try to edit `index.ts`. It sould recompile and restart node with the new shining code.

## End of the first chapter

That's all for now. In the next chapter we'll start diving in the types and in data validation.
